from dataclasses import dataclass, field
from typing import Optional

from scap.entity_state_any_simple_type import EntityStateAnySimpleType
from scap.entity_state_int_type import EntityStateIntType
from scap.entity_state_string_type import EntityStateStringType
from scap.entity_state_windows_view_type import EntityStateWindowsViewType
from scap.state_type import StateType
import sys

from scap.operation_enumeration import OperationEnumeration

__NAMESPACE__ = (
    "http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
)


@dataclass
class Textfilecontent54State(StateType):
    """
    The textfilecontent54_state element contains entities that are used to check
    the file path and name, as well as the text block in question and the value of
    the subexpressions.

    :ivar filepath: The filepath element specifies the absolute path for
        a file on the machine. A directory cannot be specified as a
        filepath.
    :ivar path: The path element specifies the directory component of
        the absolute path to a file on the machine.
    :ivar filename: The filename entity represents the name of a file.
    :ivar pattern: The pattern entity represents a regular expression
        that is used to define a block of text.
    :ivar instance: The instance entity calls out a specific match of
        the pattern. This can only be a positive integer.
    :ivar text: The text entity represents the block of text that
        matched the specified pattern.
    :ivar subexpression: The subexpression entity represents a value to
        test against the subexpression in the specified pattern. If
        multiple subexpressions are specified in the pattern, this value
        is tested against all of them. For example, if the pattern
        abc(.*)mno(.*)xyp was supplied, and the state specifies a
        subexpression value of enabled, then the test would check that
        both (or at least one, none, etc. depending on the entity_check
        attribute) of the subexpressions have a value of enabled.
    :ivar windows_view: The windows view value to which this was
        targeted. This is used to indicate which view (32-bit or
        64-bit), the associated State applies to.  This entity only
        applies to 64-bit Microsoft Windows operating systems.
    """

    def generate_check(self, data):
        # Interestingly enough, the schema is pretty similar between object + state here. 
        command = ""
        print(f"TextFileContent54 State! {self.id}")
        filter = ""
        if self.instance:
            print("TextFileContent54 STATE: Instance Detected")
            filter = " | "
            if self.instance.operation is OperationEnumeration.GREATER_THAN_OR_EQUAL:
                if self.instance.value > 0:
                    filter += f"tail -n +{self.instance.value}"
                else:
                    filter += f"tail -n {abs(self.instance.value)}"
            elif self.instance.operation is OperationEnumeration.EQUALS:
                if self.instance.value > 0:
                    filter += f"sed -n {self.instance.value}p"
                else:
                    filter += f"tail {self.instance.value} | head -1"
            else:
                # Throw, since unimplemented
                print(f"ERROR: Unimplemented Instance Operation {self.instance.operation}!")
                sys.exit(-1)      
        if self.subexpression:
            print("TextFileContent54: STATE Subexpression Detected")  
            # TODO: A frustration that I've found with the standard GNU grep is that it does not have an option
            # To only print the matching group, which is essential for these sort of subexpression calls to work!
            # I don't really want to require users to install a package on their system to use our checks, 
            # especially since the entire idea of having these checks autogenerated into bash is to enable portability
            # I've decided to reluctantly use Perl to perform these checks, since Perl can do this. 
            # It seems like perl -ne is a nice drop-in replacement for the way I'm using grep.
            # Plus, it has the added benefit of being a default install on RHELs and Ubuntus.

            # Now we need to evaluate variables, etc, to grab the value
            # We will want to return this back to the test level so that it can be compared to all of the 
            # Returned subexpressions in the object, based specifically on the attributes of this subexpression
            print("TextFileContent54: STATE Sub Detected")
            # This will need to be compared to the return value from the object's query
            # Identify operation, and relevant operation
            # We could maybe directly create a table to associate certain comparisons with certain commands
            # case insensitive equals: diff -i 
            # case insensitive not equal: 
            # equals: diff 
            # greater than or equal: -ge, cast to number
            # greater than: -gt, cast to number
            # less than: -lt, cast to number
            # less than or equal: -le
            # bitwise and: &
            # bitwise or: |
            # pattern match: grep 
            # subset of: grep? grep superset for subset
            # superset of: grep superset for subset 
            #variable = data["variables"][self.subexpression.var_ref].generate_check(data)
            # Apply to matching group, which SHOULD be the group that grep grabs already! And if we have multiple returned matching groups, that should be fine too
            #print(variable)
        elif self.text:
            print("TextFileContent54: STATE Text Detected")
        elif self.filepath:
            print("TextFileContent54: STATE Filepath Detected")
            if ((not self.filepath.operation) or self.filepath.operation in [OperationEnumeration.EQUALS]):
                command = f"grep -h \"{self.pattern.value}\" {self.filepath.value}"
            elif self.filepath.operation == OperationEnumeration.PATTERN_MATCH:
                command = f"find / -regextype posix-egrep -regex \"{self.filepath.value}\" -exec grep -P \"{self.pattern.value}\"" + "{} \\;"
            else:
                print(f"ERROR: Unable to process filepath!")
                sys.exit(-1)
        elif self.filename:
            print("TextFileContent54: STATE Filename Detected")
        elif self.filename and self.path:
            print("TextFileContent54: STATE Filename and Depth Detected")
            command = f"find / -regextype posix-egrep -regex \"{self.path.value + "/" + self.filename.value}\" -exec grep -P \"{self.pattern.value}\"" + "{} \\;"
        elif self.set:
            print("TextFileContent54: STATE Set Detected")
            command = self.set.generate_check(data)
        else:
            print(f"ERROR: Unimplemented Object State! No Instance, No Set!")
            sys.exit(-1)
        #print(command + filter)
        return command + filter

    class Meta:
        name = "textfilecontent54_state"
        namespace = (
            "http://oval.mitre.org/XMLSchema/oval-definitions-5#independent"
        )

    filepath: Optional[EntityStateStringType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
    path: Optional[EntityStateStringType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
    filename: Optional[EntityStateStringType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
    pattern: Optional[EntityStateStringType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
    instance: Optional[EntityStateIntType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
    text: Optional[EntityStateAnySimpleType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
    subexpression: Optional[EntityStateAnySimpleType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
    windows_view: Optional[EntityStateWindowsViewType] = field(
        default=None,
        metadata={
            "type": "Element",
            
        },
    )
