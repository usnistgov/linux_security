#
# Rule Namer Script
#
# This script is really simple, all it does is take the B1 and C1 columns in our spreadsheet and combine them to generate the rule names
# Which, once defined, will allow the populate_rule_yaml script to populate all of the rules (as it won't until they have names)
# Originally, I had these as two scripts, but I realized that the naming convention wasn't totally consistent with this rule.
# Then I also realized that people may want different naming conventions, but for the sake of demoing (and not having to type in 200+ rule names), here we are :)

#!/usr/bin/env python3
import openpyxl
import os
import glob
import argparse
import sys
import re
import yaml
from pathlib import Path
from bs4 import BeautifulSoup

# Compile the provided regex
# Then match it with the target string, and substring after the first match
# Just a simple helper function
# Maybe not the greatest naming :)
def compile_and_inverse_match(regex,targetstring):
    compiled = re.compile(regex)
    match = compiled.split(targetstring)
    if match is not None:
        return match
    else:
        return None

def main():
    # You may note that some of this code is shamelessly borrowed from the populate_rule_yaml script, comments and all
    # For how simple this script is, I think that's just fine
    # Get the root directory of the git repo we should be inside of
    root_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    
    # Create arguments parser
    parser = argparse.ArgumentParser(description='Provide an XLSX file to have names autogenerated for. It should have the filename blanked in A1, the category in B1, and the rule ID in C1')
    parser.add_argument("--spreadsheet", default=None, help="Excel spreadsheet containing desired rules and names for STIGs and CIS")

    try:
        # Parse our arguments 
        results = parser.parse_args()
        print("Using the spreadsheet at this path: " + results.spreadsheet)
    except IOError as msg:
        # TODO: This really should be cleaner error handling
        parser.error(str(msg))

    # Attempt to load the working XLSX spreadsheet which we've specified the path to in args
    # Load the workbook
    try:
        workbook = openpyxl.load_workbook(results.spreadsheet)
    except FileNotFoundError as err:
        # TODO: Does this cover other exceptions besides just the file not existing?
        # TODO: Make this error handling better and more verbose for end users
        print("Error loading the spreadsheet. Exiting...")
        sys.exit(-1)

    # Select the active sheet
    sheet = workbook.active

    # Iterate through each row in our spreadsheet
    modified_rules=0
    row_index=2
    # Skip the first row as this is the column titles
    for row in sheet.iter_rows(min_row=2,values_only=True):
        # Skip empty rows
        if row[1]:
            if (not row[0]) and (row[2] or row[4]):
                ruleid = row[2] if row[2] else row[4]
                substring = compile_and_inverse_match(r"xccdf\_org\.ssgproject\.content\_rule",ruleid)
                if len(substring) < 2:
                    print("ERROR: Regex match failure for rule ID. Is there a typo in the spreadsheet? This should not fail normally.")
                    sys.exit(-1)
                else:
                    newname = (row[1] + substring[1] + ".yaml").replace("-","_")
                    sheet.cell(row=row_index,column=1).value = newname
                    print(f"{ruleid} has been named {newname}")
                    modified_rules += 1
            else:
                print(f"{row[0]} is already named.")
        row_index+=1
    print(f"Successfully modified {modified_rules} rows.")
    workbook.save("C:\\Users\\zka\\Downloads\\SCPLinux_Status_Log_GenTest.xlsx")
main()